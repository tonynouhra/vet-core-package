"""
Integration tests for complete vulnerability management workflow.

This module provides comprehensive end-to-end testing of the vulnerability
management system, including discovery, assessment, remediation, and compliance
reporting workflows.

Requirements addressed:
- 1.1: End-to-end vulnerability detection and reporting
- 1.3: Complete vulnerability management workflow validation
- 2.1: Safe upgrade pipeline integration testing
- 3.1: Security monitoring and scanning integration
- 4.1: Audit trail and compliance reporting validation
"""

import json
import os
import tempfile
import pytest
import subprocess
import time
from datetime import datetime, timedelta
from pathlib import Path
from unittest.mock import Mock, patch, MagicMock
from typing import Dict, List, Any

from vet_core.security.scanner import VulnerabilityScanner
from vet_core.security.assessor import RiskAssessor
from vet_core.security.upgrade_validator import UpgradeValidator
from vet_core.security.audit_trail import SecurityAuditTrail, AuditEventType
from vet_core.security.compliance import SecurityComplianceManager, ComplianceFramework
from vet_core.security.notifications import SecurityNotifier, NotificationConfig
from vet_core.security.models import (
    Vulnerability,
    VulnerabilitySeverity,
    SecurityReport,
    RemediationAction,
)


class TestVulnerabilityManagementWorkflow:
    """Integration tests for complete vulnerability management workflow."""

    @pytest.fixture
    def temp_workspace(self):
        """Create temporary workspace for testing."""
        with tempfile.TemporaryDirectory() as temp_dir:
            workspace = Path(temp_dir)
            
            # Create basic project structure
            (workspace / "pyproject.toml").write_text("""
[build-system]
requires = ["setuptools>=45", "wheel"]
build-backend = "setuptools.build_meta"

[project]
name = "test-project"
version = "1.0.0"
dependencies = [
    "black==23.12.1",
    "setuptools==65.5.0",
    "requests>=2.25.0",
]

[project.optional-dependencies]
dev = [
    "pytest>=6.0.0",
    "mypy>=0.900",
]
""")
            
            # Create basic test file
            (workspace / "test_basic.py").write_text("""
def test_example():
    assert True
""")
            
            yield workspace

    @pytest.fixture
    def mock_vulnerability_data(self):
        """Mock vulnerability data for testing."""
        return {
            "dependencies": [
                {
                    "name": "black",
                    "version": "23.12.1",
                    "vulns": [
                        {
                            "id": "PYSEC-2024-48",
                            "fix_versions": ["24.3.0"],
                            "description": "Code formatting vulnerability in black",
                            "aliases": ["CVE-2024-12345"],
                        }
                    ],
                },
                {
                    "name": "setuptools",
                    "version": "65.5.0",
                    "vulns": [
                        {
                            "id": "PYSEC-2022-43012",
                            "fix_versions": ["65.5.1", "78.1.1"],
                            "description": "Build system vulnerability in setuptools",
                            "aliases": ["CVE-2022-12345"],
                        },
                        {
                            "id": "PYSEC-2025-49",
                            "fix_versions": ["78.1.1"],
                            "description": "Recent vulnerability in setuptools",
                            "aliases": ["CVE-2025-12345"],
                        },
                    ],
                },
            ]
        }

    @pytest.fixture
    def integrated_security_system(self, temp_workspace):
        """Create integrated security system for testing."""
        # Initialize audit trail
        audit_db_path = temp_workspace / "security-audit.db"
        audit_log_path = temp_workspace / "security-audit.log"
        audit_trail = SecurityAuditTrail(
            audit_db_path=audit_db_path,
            log_file_path=audit_log_path,
            retention_days=30,
        )

        # Initialize components
        scanner = VulnerabilityScanner(timeout=60)
        risk_assessor = RiskAssessor()
        compliance_manager = SecurityComplianceManager(audit_trail, risk_assessor)
        
        # Initialize notification config (mock)
        notification_config = NotificationConfig(
            min_severity_for_email=VulnerabilitySeverity.HIGH,
            min_severity_for_slack=VulnerabilitySeverity.MEDIUM,
            min_severity_for_github_issue=VulnerabilitySeverity.CRITICAL,
        )
        notifier = SecurityNotifier(notification_config)

        return {
            "scanner": scanner,
            "risk_assessor": risk_assessor,
            "audit_trail": audit_trail,
            "compliance_manager": compliance_manager,
            "notifier": notifier,
            "workspace": temp_workspace,
        }

    def test_complete_vulnerability_discovery_workflow(
        self, integrated_security_system, mock_vulnerability_data
    ):
        """Test complete vulnerability discovery and assessment workflow."""
        system = integrated_security_system
        scanner = system["scanner"]
        risk_assessor = system["risk_assessor"]
        audit_trail = system["audit_trail"]

        # Mock pip-audit execution
        with patch("subprocess.run") as mock_run:
            mock_result = Mock()
            mock_result.returncode = 1  # Vulnerabilities found
            mock_result.stdout = json.dumps(mock_vulnerability_data)
            mock_result.stderr = ""
            mock_run.return_value = mock_result

            with patch.object(
                scanner, "_get_scanner_version", return_value="pip-audit 2.6.1"
            ):
                # Step 1: Scan for vulnerabilities
                scan_id = f"scan_{int(time.time())}"
                audit_trail.log_scan_initiated(scan_id, "pip-audit")

                report = scanner.scan_dependencies()

                audit_trail.log_scan_completed(scan_id, report, 45.2)

                # Verify scan results
                assert report.vulnerability_count == 3
                assert len(report.vulnerabilities) == 3

                # Step 2: Log vulnerability detection
                for vulnerability in report.vulnerabilities:
                    audit_trail.log_vulnerability_detected(vulnerability, scan_id)

                # Step 3: Perform risk assessment
                assessments = risk_assessor.assess_report(report)

                assert len(assessments) == 3
                for assessment in assessments:
                    audit_trail.log_risk_assessment(
                        assessment.vulnerability_id, assessment
                    )

                # Step 4: Verify audit trail
                events = audit_trail.get_audit_events()
                assert len(events) >= 7  # 1 scan init + 1 scan complete + 3 vuln detected + 3 risk assessments

                # Verify event types
                event_types = [event.event_type for event in events]
                assert AuditEventType.SCAN_INITIATED in event_types
                assert AuditEventType.SCAN_COMPLETED in event_types
                assert AuditEventType.VULNERABILITY_DETECTED in event_types
                assert AuditEventType.RISK_ASSESSMENT_PERFORMED in event_types

                # Step 5: Get prioritized vulnerabilities
                prioritized = risk_assessor.get_prioritized_vulnerabilities(report)

                # Verify prioritization
                assert "immediate" in prioritized or "urgent" in prioritized
                total_prioritized = sum(len(vulns) for vulns in prioritized.values())
                assert total_prioritized == 3

    def test_github_actions_workflow_simulation(
        self, integrated_security_system, mock_vulnerability_data, temp_workspace
    ):
        """Test GitHub Actions workflow integration."""
        system = integrated_security_system
        scanner = system["scanner"]
        audit_trail = system["audit_trail"]
        workspace = system["workspace"]

        # Create mock GitHub Actions environment
        env_vars = {
            "GITHUB_ACTIONS": "true",
            "GITHUB_REPOSITORY": "test-org/test-repo",
            "GITHUB_RUN_ID": "123456789",
            "GITHUB_SHA": "abc123def456",
        }

        with patch.dict(os.environ, env_vars):
            # Create security reports directory (as GitHub Actions would)
            reports_dir = workspace / "security-reports"
            reports_dir.mkdir(exist_ok=True)

            # Mock pip-audit execution
            with patch("subprocess.run") as mock_run:
                mock_result = Mock()
                mock_result.returncode = 1
                mock_result.stdout = json.dumps(mock_vulnerability_data)
                mock_result.stderr = ""
                mock_run.return_value = mock_result

                with patch.object(
                    scanner, "_get_scanner_version", return_value="pip-audit 2.6.1"
                ):
                    # Simulate GitHub Actions workflow steps
                    
                    # Step 1: Run vulnerability scan
                    output_file = reports_dir / "pip-audit-raw.json"
                    report = scanner.scan_dependencies(output_file=output_file)

                    # Verify output file was created (simulated)
                    # In real GitHub Actions, this would be created by pip-audit
                    output_file.write_text(json.dumps(mock_vulnerability_data))
                    assert output_file.exists()

                    # Step 2: Process vulnerability report
                    processed_report = scanner.scan_from_file(output_file)
                    assert processed_report.vulnerability_count == report.vulnerability_count

                    # Step 3: Generate security summary
                    summary_file = reports_dir / "security-summary.md"
                    summary_content = self._generate_security_summary(processed_report)
                    summary_file.write_text(summary_content)

                    # Step 4: Generate JSON report
                    json_report_file = reports_dir / "security-report.json"
                    json_report = {
                        "scan_metadata": {
                            "scan_date": report.scan_date.isoformat(),
                            "total_vulnerabilities": report.vulnerability_count,
                            "scanner_version": report.scanner_version,
                        },
                        "vulnerabilities": [
                            {
                                "id": v.id,
                                "package_name": v.package_name,
                                "installed_version": v.installed_version,
                                "fix_versions": v.fix_versions,
                                "severity": v.severity.value,
                                "description": v.description,
                            }
                            for v in report.vulnerabilities
                        ],
                    }
                    json_report_file.write_text(json.dumps(json_report, indent=2))

                    # Step 5: Verify all expected files exist
                    assert summary_file.exists()
                    assert json_report_file.exists()
                    assert output_file.exists()

                    # Step 6: Simulate artifact upload validation
                    artifact_files = list(reports_dir.glob("*"))
                    assert len(artifact_files) >= 3

                    # Step 7: Log GitHub Actions workflow completion
                    audit_trail.log_event(
                        audit_trail.AuditEvent(
                            event_type=AuditEventType.SCAN_COMPLETED,
                            action_taken="github_actions_workflow",
                            outcome="completed",
                            details={
                                "workflow_run_id": env_vars["GITHUB_RUN_ID"],
                                "repository": env_vars["GITHUB_REPOSITORY"],
                                "artifacts_generated": len(artifact_files),
                            },
                        )
                    )

    def test_upgrade_validation_workflow(
        self, integrated_security_system, mock_vulnerability_data
    ):
        """Test safe upgrade validation workflow."""
        system = integrated_security_system
        scanner = system["scanner"]
        audit_trail = system["audit_trail"]
        workspace = system["workspace"]

        # Mock pip-audit to find vulnerabilities
        with patch("subprocess.run") as mock_run:
            # First call: pip-audit scan
            mock_scan_result = Mock()
            mock_scan_result.returncode = 1
            mock_scan_result.stdout = json.dumps(mock_vulnerability_data)
            mock_scan_result.stderr = ""

            # Subsequent calls: pip show, pip install, pytest
            mock_pip_show = Mock()
            mock_pip_show.returncode = 0
            mock_pip_show.stdout = "Version: 23.12.1"

            mock_pip_install = Mock()
            mock_pip_install.returncode = 0
            mock_pip_install.stdout = ""

            mock_pytest = Mock()
            mock_pytest.returncode = 0
            mock_pytest.stdout = "= 5 passed in 2.34s ="

            mock_run.side_effect = [
                mock_scan_result,  # pip-audit scan
                mock_pip_show,     # pip show black
                mock_pip_install,  # pip install black==24.3.0
                mock_pytest,       # pytest
            ]

            with patch.object(
                scanner, "_get_scanner_version", return_value="pip-audit 2.6.1"
            ):
                # Step 1: Discover vulnerabilities
                report = scanner.scan_dependencies()
                
                # Step 2: Find upgradeable vulnerabilities
                black_vuln = next(
                    v for v in report.vulnerabilities 
                    if v.package_name == "black"
                )

                # Step 3: Validate upgrade
                with UpgradeValidator(workspace) as validator:
                    upgrade_result = validator.validate_upgrade(
                        package_name="black",
                        target_version="24.3.0",
                        run_tests=True,
                        check_conflicts=True,
                    )

                    # Verify upgrade validation
                    assert upgrade_result.success
                    assert upgrade_result.package_name == "black"
                    assert upgrade_result.to_version == "24.3.0"
                    assert "test_results" in upgrade_result.test_results

                    # Step 4: Log remediation action
                    remediation = RemediationAction(
                        vulnerability_id=black_vuln.id,
                        action_type="upgrade",
                        target_version="24.3.0",
                        status="completed",
                        notes="Upgrade validation successful",
                    )
                    remediation.mark_started()
                    remediation.mark_completed("Tests passed, upgrade safe")

                    audit_trail.log_remediation_action(
                        remediation, AuditEventType.REMEDIATION_COMPLETED
                    )

                    # Step 5: Log vulnerability resolution
                    audit_trail.log_vulnerability_resolved(
                        black_vuln.id,
                        black_vuln.package_name,
                        "package_upgrade",
                        "24.3.0",
                    )

                    # Step 6: Verify audit trail
                    remediation_events = audit_trail.get_audit_events(
                        event_type=AuditEventType.REMEDIATION_COMPLETED
                    )
                    assert len(remediation_events) == 1

                    resolution_events = audit_trail.get_audit_events(
                        event_type=AuditEventType.VULNERABILITY_RESOLVED
                    )
                    assert len(resolution_events) == 1

    def test_compliance_reporting_workflow(
        self, integrated_security_system, mock_vulnerability_data
    ):
        """Test compliance reporting and audit trail workflow."""
        system = integrated_security_system
        scanner = system["scanner"]
        audit_trail = system["audit_trail"]
        compliance_manager = system["compliance_manager"]
        workspace = system["workspace"]

        # Mock vulnerability scan
        with patch("subprocess.run") as mock_run:
            mock_result = Mock()
            mock_result.returncode = 1
            mock_result.stdout = json.dumps(mock_vulnerability_data)
            mock_result.stderr = ""
            mock_run.return_value = mock_result

            with patch.object(
                scanner, "_get_scanner_version", return_value="pip-audit 2.6.1"
            ):
                # Step 1: Generate security report
                report = scanner.scan_dependencies()

                # Step 2: Log vulnerabilities
                for vulnerability in report.vulnerabilities:
                    audit_trail.log_vulnerability_detected(vulnerability)

                # Step 3: Check compliance
                violations, metrics = compliance_manager.check_compliance(report)

                # Verify compliance check
                assert isinstance(violations, list)
                assert metrics.total_vulnerabilities == report.vulnerability_count

                # Step 4: Generate compliance report for NIST CSF
                compliance_report = compliance_manager.generate_compliance_report(
                    framework=ComplianceFramework.NIST_CSF,
                    output_file=workspace / "nist-compliance-report.json",
                )

                # Verify compliance report structure
                assert "report_metadata" in compliance_report
                assert "executive_summary" in compliance_report
                assert "framework_requirements" in compliance_report
                assert "audit_trail_summary" in compliance_report

                # Verify NIST CSF specific content
                framework_content = compliance_report["framework_requirements"]
                assert framework_content["framework"] == "NIST Cybersecurity Framework"
                assert "functions" in framework_content
                assert "identify" in framework_content["functions"]
                assert "protect" in framework_content["functions"]
                assert "detect" in framework_content["functions"]
                assert "respond" in framework_content["functions"]
                assert "recover" in framework_content["functions"]

                # Step 5: Generate ISO 27001 compliance report
                iso_report = compliance_manager.generate_compliance_report(
                    framework=ComplianceFramework.ISO_27001,
                    output_file=workspace / "iso27001-compliance-report.json",
                )

                # Verify ISO 27001 specific content
                iso_framework = iso_report["framework_requirements"]
                assert iso_framework["framework"] == "ISO 27001:2013"
                assert "controls" in iso_framework

                # Step 6: Verify compliance files were created
                assert (workspace / "nist-compliance-report.json").exists()
                assert (workspace / "iso27001-compliance-report.json").exists()

                # Step 7: Generate comprehensive audit report
                audit_report = audit_trail.generate_compliance_report()

                # Verify audit report structure
                assert "report_metadata" in audit_report
                assert "executive_summary" in audit_report
                assert "event_summary" in audit_report
                assert "vulnerability_lifecycle_analysis" in audit_report

    def test_notification_system_integration(
        self, integrated_security_system, mock_vulnerability_data
    ):
        """Test notification system integration."""
        system = integrated_security_system
        scanner = system["scanner"]
        notifier = system["notifier"]

        # Mock vulnerability scan
        with patch("subprocess.run") as mock_run:
            mock_result = Mock()
            mock_result.returncode = 1
            mock_result.stdout = json.dumps(mock_vulnerability_data)
            mock_result.stderr = ""
            mock_run.return_value = mock_result

            with patch.object(
                scanner, "_get_scanner_version", return_value="pip-audit 2.6.1"
            ):
                # Step 1: Generate security report
                report = scanner.scan_dependencies()

                # Step 2: Mock notification channels
                with patch.object(
                    notifier, "_get_available_channels", return_value=["slack"]
                ), patch.object(
                    notifier, "_send_slack_notification", return_value=True
                ) as mock_slack:
                    
                    # Step 3: Send vulnerability alert
                    results = notifier.send_vulnerability_alert(
                        report, channels=["slack"]
                    )

                    # Verify notification was sent
                    assert results["slack"] is True
                    mock_slack.assert_called_once()

                    # Step 4: Send remediation update
                    update_results = notifier.send_remediation_update(
                        vulnerability_id="PYSEC-2024-48",
                        status="completed",
                        notes="Successfully upgraded black to 24.3.0",
                        channels=["slack"],
                    )

                    # Verify update was sent
                    assert "slack" in update_results

    def test_end_to_end_vulnerability_lifecycle(
        self, integrated_security_system, mock_vulnerability_data
    ):
        """Test complete end-to-end vulnerability lifecycle."""
        system = integrated_security_system
        scanner = system["scanner"]
        risk_assessor = system["risk_assessor"]
        audit_trail = system["audit_trail"]
        compliance_manager = system["compliance_manager"]
        notifier = system["notifier"]
        workspace = system["workspace"]

        # Mock all external calls
        with patch("subprocess.run") as mock_run, \
             patch.object(notifier, "_get_available_channels", return_value=[]), \
             patch.object(scanner, "_get_scanner_version", return_value="pip-audit 2.6.1"):

            # Mock pip-audit scan
            mock_scan_result = Mock()
            mock_scan_result.returncode = 1
            mock_scan_result.stdout = json.dumps(mock_vulnerability_data)
            mock_scan_result.stderr = ""
            mock_run.return_value = mock_scan_result

            # PHASE 1: DISCOVERY
            scan_id = f"e2e_scan_{int(time.time())}"
            audit_trail.log_scan_initiated(scan_id, "pip-audit")

            report = scanner.scan_dependencies()
            audit_trail.log_scan_completed(scan_id, report, 45.2)

            # Log vulnerability detection
            for vulnerability in report.vulnerabilities:
                audit_trail.log_vulnerability_detected(vulnerability, scan_id)

            # PHASE 2: ASSESSMENT
            assessments = risk_assessor.assess_report(report)
            for assessment in assessments:
                audit_trail.log_risk_assessment(
                    assessment.vulnerability_id, assessment
                )

            prioritized = risk_assessor.get_prioritized_vulnerabilities(report)

            # PHASE 3: COMPLIANCE CHECK
            violations, metrics = compliance_manager.check_compliance(report)

            # PHASE 4: REMEDIATION PLANNING
            remediation_actions = []
            for priority_level, vuln_assessments in prioritized.items():
                for vulnerability, assessment in vuln_assessments:
                    if vulnerability.is_fixable:
                        remediation = RemediationAction(
                            vulnerability_id=vulnerability.id,
                            action_type="upgrade",
                            target_version=vulnerability.recommended_fix_version,
                            status="planned",
                            notes=f"Priority: {priority_level}, Risk: {assessment.risk_score:.1f}",
                        )
                        remediation_actions.append(remediation)

            # PHASE 5: SIMULATED REMEDIATION
            for remediation in remediation_actions:
                # Start remediation
                remediation.mark_started()
                audit_trail.log_remediation_action(
                    remediation, AuditEventType.REMEDIATION_STARTED
                )

                # Simulate successful remediation
                remediation.mark_completed("Upgrade completed successfully")
                audit_trail.log_remediation_action(
                    remediation, AuditEventType.REMEDIATION_COMPLETED
                )

                # Log vulnerability resolution
                vulnerability = next(
                    v for v in report.vulnerabilities 
                    if v.id == remediation.vulnerability_id
                )
                audit_trail.log_vulnerability_resolved(
                    vulnerability.id,
                    vulnerability.package_name,
                    "package_upgrade",
                    remediation.target_version,
                )

            # PHASE 6: VERIFICATION
            # Verify complete audit trail
            all_events = audit_trail.get_audit_events()
            
            # Should have events for each phase
            event_types = [event.event_type for event in all_events]
            assert AuditEventType.SCAN_INITIATED in event_types
            assert AuditEventType.SCAN_COMPLETED in event_types
            assert AuditEventType.VULNERABILITY_DETECTED in event_types
            assert AuditEventType.RISK_ASSESSMENT_PERFORMED in event_types
            assert AuditEventType.REMEDIATION_STARTED in event_types
            assert AuditEventType.REMEDIATION_COMPLETED in event_types
            assert AuditEventType.VULNERABILITY_RESOLVED in event_types

            # Verify vulnerability lifecycle tracking
            for vulnerability in report.vulnerabilities:
                timeline = audit_trail.get_vulnerability_timeline(vulnerability.id)
                timeline_types = [event.event_type for event in timeline]
                
                assert AuditEventType.VULNERABILITY_DETECTED in timeline_types
                if vulnerability.is_fixable:
                    assert AuditEventType.VULNERABILITY_RESOLVED in timeline_types

            # PHASE 7: COMPLIANCE REPORTING
            final_compliance_report = compliance_manager.generate_compliance_report(
                framework=ComplianceFramework.NIST_CSF,
                output_file=workspace / "final-compliance-report.json",
            )

            # Verify comprehensive compliance report
            assert final_compliance_report["executive_summary"]["security_posture"]["vulnerabilities_resolved"] > 0
            assert (workspace / "final-compliance-report.json").exists()

            # PHASE 8: METRICS VALIDATION
            final_metrics = audit_trail.calculate_compliance_metrics(report)
            
            # Verify metrics calculation
            assert final_metrics.total_vulnerabilities == report.vulnerability_count
            assert final_metrics.compliance_score >= 0.0
            assert final_metrics.compliance_score <= 100.0

            # Verify audit trail completeness
            assert len(all_events) >= 10  # Minimum expected events for complete workflow

    def test_error_handling_and_recovery(
        self, integrated_security_system, mock_vulnerability_data
    ):
        """Test error handling and recovery in the workflow."""
        system = integrated_security_system
        scanner = system["scanner"]
        audit_trail = system["audit_trail"]

        # Test scanner failure recovery
        with patch("subprocess.run") as mock_run:
            # First call fails
            mock_run.side_effect = subprocess.CalledProcessError(2, "pip-audit")

            with pytest.raises(Exception):
                scanner.scan_dependencies()

            # Verify error was logged (scanner should handle this internally)
            # Second call succeeds
            mock_run.side_effect = None
            mock_result = Mock()
            mock_result.returncode = 1
            mock_result.stdout = json.dumps(mock_vulnerability_data)
            mock_result.stderr = ""
            mock_run.return_value = mock_result

            with patch.object(
                scanner, "_get_scanner_version", return_value="pip-audit 2.6.1"
            ):
                # Recovery should work
                report = scanner.scan_dependencies()
                assert report.vulnerability_count > 0

        # Test audit trail resilience
        try:
            # This should not crash the system
            audit_trail.log_event(None)
        except Exception:
            pass  # Expected to fail gracefully

        # Verify system can continue operating
        events = audit_trail.get_audit_events()
        assert isinstance(events, list)

    def _generate_security_summary(self, report) -> str:
        """Generate security summary markdown for testing."""
        return f"""# Security Vulnerability Report

**Scan Date:** {report.scan_date.strftime('%Y-%m-%d %H:%M:%S UTC')}
**Total Vulnerabilities:** {report.vulnerability_count}

## Severity Breakdown
- **Critical:** {report.critical_count}
- **High:** {report.high_count}
- **Medium:** {report.medium_count}
- **Low:** {report.low_count}

## Vulnerabilities Found

{chr(10).join(f"- **{v.id}** - {v.package_name} {v.installed_version}" for v in report.vulnerabilities)}

## Next Steps
1. Review all vulnerabilities
2. Apply available fixes
3. Monitor for updates
"""


class TestGitHubActionsWorkflowValidation:
    """Test GitHub Actions workflow components."""

    def test_workflow_file_validation(self):
        """Test GitHub Actions workflow file structure."""
        workflow_file = Path("vet-core-package/.github/workflows/security-monitoring.yml")
        
        if workflow_file.exists():
            import yaml
            
            with open(workflow_file) as f:
                workflow = yaml.safe_load(f)
            
            # Verify workflow structure
            assert "name" in workflow
            assert "on" in workflow
            assert "jobs" in workflow
            
            # Verify scheduled scanning
            assert "schedule" in workflow["on"]
            
            # Verify vulnerability scan job
            assert "vulnerability-scan" in workflow["jobs"]
            
            scan_job = workflow["jobs"]["vulnerability-scan"]
            assert "steps" in scan_job
            
            # Verify key steps exist
            step_names = [step.get("name", "") for step in scan_job["steps"]]
            assert any("pip-audit" in name.lower() for name in step_names)
            assert any("upload" in name.lower() for name in step_names)

    def test_workflow_script_integration(self, temp_workspace):
        """Test workflow processing scripts."""
        # Create mock GitHub Actions environment
        reports_dir = temp_workspace / "security-reports"
        reports_dir.mkdir()
        
        # Create mock pip-audit output
        mock_output = {
            "dependencies": [
                {
                    "name": "test-package",
                    "version": "1.0.0",
                    "vulns": [
                        {
                            "id": "TEST-001",
                            "fix_versions": ["1.1.0"],
                            "description": "Test vulnerability",
                        }
                    ],
                }
            ]
        }
        
        raw_report_file = reports_dir / "pip-audit-raw.json"
        raw_report_file.write_text(json.dumps(mock_output))
        
        # Test processing with scanner
        scanner = VulnerabilityScanner()
        report = scanner.scan_from_file(raw_report_file)
        
        assert report.vulnerability_count == 1
        assert report.vulnerabilities[0].id == "TEST-001"


if __name__ == "__main__":
    pytest.main([__file__, "-v"])